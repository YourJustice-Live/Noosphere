type AvatarNftEntity @entity {
  id: ID! # token id
  owner: Bytes! # account address
  uri: String # metadata uri
  reputations: [AvatarNftReputationEntity!]! @derivedFrom(field: "token")
}

type AvatarNftReputationEntity @entity {
  id: ID! # combination of token id and domain id
  token: AvatarNftEntity!
  domain: Int!
  negativeRating: BigInt
  positiveRating: BigInt
}

type JurisdictionParticipantEntity @entity {
  id: ID! # account address
  isAdmin: Boolean
  isMember: Boolean
  isJudge: Boolean
}

# TODO: ID should be a combination of jurisdiction address and rule id
# TODO: Add jurisdiction relationship
type JurisdictionRuleEntity @entity {
  id: ID!
  about: ActionEntity!
  affected: String
  uri: String
  negation: Boolean
  effectsEnvironmental: Int
  effectsPersonal: Int
  effectsSocial: Int
  effectsProfessional: Int
  confirmationRuling: String
  confirmationEvidence: Boolean
  confirmationWitness: BigInt
}

type ActionEntity @entity {
  id: ID! # guid
  subject: String
  verb: String
  object: String
  tool: String
  uri: String
  rules: [JurisdictionRuleEntity!]! @derivedFrom(field: "about")
}

type CaseEntity @entity {
  id: ID! # contract address
  jurisdiction: Bytes!
  rules: [JurisdictionRuleEntity!]!
  participants: [CaseParticipantEntity!]! @derivedFrom(field: "caseEntity")
  posts: [CasePostEntity!]! @derivedFrom(field: "caseEntity")
}

type CaseParticipantEntity @entity {
  id: ID! # combination of case address and accout address
  caseEntity: CaseEntity!
  account: Bytes!
  isAdmin: Boolean
  isSubject: Boolean
  isPlaintiff: Boolean
  isJudge: Boolean
  isWitness: Boolean
  isAffected: Boolean
}

type CasePostEntity @entity {
  id: ID! # transaction address
  caseEntity: CaseEntity!
  entityRole: String
  postRole: String
  uri: String
}