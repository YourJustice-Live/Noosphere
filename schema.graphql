type AvatarNftEntity @entity {
  id: ID! # token id
  owner: Bytes! # account address
  uri: String # metadata uri
  reputations: [AvatarNftReputationEntity!]! @derivedFrom(field: "token")
}

type AvatarNftReputationEntity @entity {
  id: ID! # combination of token id and domain id
  token: AvatarNftEntity!
  domain: Int!
  negativeRating: BigInt
  positiveRating: BigInt
}

# TODO: Use "JurisdictionRoleEntity" instead of "JurisdictionParticipantEntity" like "CaseRoleEntity"
type JurisdictionParticipantEntity @entity {
  id: ID! # account address
  isAdmin: Boolean
  isMember: Boolean
  isJudge: Boolean
}

# TODO: ID should be a combination of jurisdiction address and rule id
# TODO: Add field "ruleId"
type JurisdictionRuleEntity @entity {
  id: ID!
  about: ActionEntity!
  affected: String
  uri: String
  negation: Boolean
  effectsEnvironmental: Int
  effectsPersonal: Int
  effectsSocial: Int
  effectsProfessional: Int
  confirmationRuling: String
  confirmationEvidence: Boolean
  confirmationWitness: BigInt
}

type ActionEntity @entity {
  id: ID! # guid
  subject: String
  verb: String
  object: String
  tool: String
  uri: String
  rules: [JurisdictionRuleEntity!]! @derivedFrom(field: "about")
}

type CaseEntity @entity {
  id: ID! # contract address
  createdDate: BigInt
  jurisdiction: Bytes!
  stage: Int
  verdictUri: String
  rules: [JurisdictionRuleEntity!]!
  roles: [CaseRoleEntity!]! @derivedFrom(field: "caseEntity")
  posts: [CasePostEntity!]! @derivedFrom(field: "caseEntity")
}

type CaseRoleEntity @entity {
  id: ID! # combination of case address and role id
  caseEntity: CaseEntity!
  roleId: BigInt
  accounts: [Bytes!]!
}

# TODO: ID Should be combination of case address and post transaction address
type CasePostEntity @entity {
  id: ID! # transaction address
  caseEntity: CaseEntity!
  entityRole: String
  postRole: String
  uri: String
}