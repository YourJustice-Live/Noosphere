type AccountEntity @entity {
  id: ID! # account address
  avatarNft: AvatarNftEntity!
}

# TODO: Use account entity for owner
type AvatarNftEntity @entity {
  id: ID! # token id (string)
  tokenId: BigInt!
  owner: String! # account address
  uri: String # metadata uri
  uriData: Bytes
  uriImage: String
  uriFirstName: String
  uriLastName: String
  reputations: [AvatarNftReputationEntity!]! @derivedFrom(field: "avatarNft")
  totalNegativeRating: BigInt!
  totalPositiveRating: BigInt!
  jurisdictions: [JurisdictionEntity!]! # where avatar is a member
}

type AvatarNftReputationEntity @entity {
  id: ID! # combination of token id, jurisdiction id, and domain name
  avatarNft: AvatarNftEntity!
  jurisdiction: JurisdictionEntity!
  domain: String!
  negativeRating: BigInt!
  positiveRating: BigInt!
}

type JurisdictionEntity @entity {
  id: ID! # contract address
  name: String
  roles: [JurisdictionRoleEntity!]! @derivedFrom(field: "jurisdiction")
  rules: [JurisdictionRuleEntity!]! @derivedFrom(field: "jurisdiction")
  rulesCount: Int!
  casesCount: Int!
}

type JurisdictionRoleEntity @entity {
  id: ID! # combination of jurisdiction address and role id
  jurisdiction: JurisdictionEntity!
  roleId: BigInt!
  accounts: [Bytes!]!
  accountsCount: Int!
}

type JurisdictionRuleEntity @entity {
  id: ID! # combination of jurisdiction address and rule id
  jurisdiction: JurisdictionEntity!
  about: ActionEntity!
  ruleId: BigInt!
  affected: String
  uri: String
  uriData: Bytes
  negation: Boolean
  effects: [JurisdictionRuleEffectEntity!]! @derivedFrom(field: "rule")
  confirmationRuling: String
  confirmationEvidence: Boolean
  confirmationWitness: BigInt
}

type JurisdictionRuleEffectEntity @entity {
  id: ID! # combination of jurisdiction address, rule id, effect name
  rule: JurisdictionRuleEntity!
  name: String!
  direction: Boolean!
  value: Int!
}

type ActionEntity @entity {
  id: ID! # guid
  subject: String
  verb: String
  object: String
  tool: String
  uri: String
  uriData: Bytes
  rules: [JurisdictionRuleEntity!]! @derivedFrom(field: "about")
}

type CaseEntity @entity {
  id: ID! # contract address
  name: String
  createdDate: BigInt
  jurisdiction: JurisdictionEntity!
  stage: Int
  verdictAuthor: Bytes
  verdictConfirmedRules: [JurisdictionRuleEntity!]
  verdictUri: String
  verdictUriData: Bytes
  cancellationAuthor: Bytes
  cancellationUri: String
  cancellationUriData: Bytes
  rules: [JurisdictionRuleEntity!]!
  posts: [CasePostEntity!]! @derivedFrom(field: "caseEntity")
  participantAccounts: [Bytes!]!
  adminAccounts: [Bytes!]!
  subjectAccounts: [Bytes!]!
  plaintiffAccounts: [Bytes!]!
  judgeAccounts: [Bytes!]!
  witnessAccounts: [Bytes!]!
  affectedAccounts: [Bytes!]!
}

type CasePostEntity @entity {
  id: ID! # combination of case address and post transaction address
  author: Bytes!
  createdDate: BigInt
  caseEntity: CaseEntity!
  entityRole: String
  uri: String
  uriData: Bytes
  uriType: String
}

type CaseEventEntity @entity {
  id: ID! # combination of case address and event transaction address
  caseEntity: CaseEntity!
  createdDate: BigInt!
  type: String!
  data: Bytes
}